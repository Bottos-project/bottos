// Copyright 2017~2022 The Bottos Authors
// This file is part of the Bottos Chain library.
// Created by Rocket Core Team of Bottos.

//This program is free software: you can distribute it and/or modify
//it under the terms of the GNU General Public License as published by
//the Free Software Foundation, either version 3 of the License, or
//(at your option) any later version.

//This program is distributed in the hope that it will be useful,
//but WITHOUT ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//GNU General Public License for more details.

//You should have received a copy of the GNU General Public License
// along with bottos.  If not, see <http://www.gnu.org/licenses/>.

/*
 * file description:  config load
 * @Author: Gong Zibin
 * @Date:   2017-12-11
 * @Last Modified by:
 * @Last Modified time:
 */

package config

import (
	"bufio"
	"bytes"
	"fmt"
	"io/ioutil"
	"os"
	"strings"
	"time"

	"errors"
	"path/filepath"

	"github.com/bottos-project/bottos/bpl"
	"github.com/bottos-project/bottos/cmd"
	"github.com/bottos-project/bottos/common"
	log "github.com/cihub/seelog"
	"github.com/naoina/toml"
	"gopkg.in/urfave/cli.v1"
	"regexp"
)

const (
	DefaultDataDir        = "./datadir/"
	DefaultConfigToml     = "./config.toml"
	DefaultGenesisToml    = "./genesis.toml"
	DefaultRESTPort       = 8689
	DefaultWalletRESTPort = 6869
	DefaultLogRESTPort    = 6870
	DefaultRESTHost       = "localhost"
	DefaultP2PPort        = 9868
	DefaultP2PAuthRequried = false
	DefaultMaxPeer        = 500
	DefaultRPCServiceName = "bottos"
	DefaultRPCServiceVer  = "3.2.0"
)

const (
	DefaultGenesisTime = "2018-08-01T12:00:00Z"
	DefaultGenesisKey  = "0454f1c2223d553aa6ee53ea1ccea8b7bf78b8ca99f3ff622a3bb3e62dedc712089033d6091d77296547bc071022ca2838c9e86dec29667cf740e5c9e654b6127f"
	PUBKEY_LEN         = 130
)

var (
	// BtoConfig general config parameter
	BtoConfig BottosConfig
	// Genesis genesis config
	Genesis GenesisConfig
	// ChainID chain id generated by genesis config
	ChainID common.Hash
)

type BottosConfig struct {
	Node     NodeConfig
	Rest     RestConfig
	P2P      P2PConfig
	Delegate DelegateConfig
	Plugin   PluginConfig
}

type NodeConfig struct {
	DataDir string
}

type RestConfig struct {
	RESTPort int
	RESTHost string
}

type P2PConfig struct {
	P2PPort     int
	P2PServAddr string
	PeerList    []string
	P2PAuthRequried bool
	P2PAuthKeyList []string
	MaxPeer int
}

type DelegateConfig struct {
	Account   string
	Solo      bool
	Signature Signature
}

type PluginConfig struct {
	Wallet  WalletConfig
	Log     LogRestConfig
	MongoDB MongoDBConfig
}

type WalletConfig struct {
	WalletDir      string
	WalletRESTPort int
	WalletRESTHost string
}

type LogRestConfig struct {
	LogRESTPort int
	LogRESTHost string
}

type MongoDBConfig struct {
	URL string
}

// KeyPair is definition of key pair
type Signature struct {
	Type       string
	PrivateKey string
	PublicKey  string
	URL        string
}

// GenesisConfig is definition of genesis config
type GenesisConfig struct {
	GenesisTime uint64
	GenesisKey  []byte
}

func InitConfig() {
	BtoConfig = BottosConfig{
		Node: NodeConfig{
			DataDir: DefaultDataDir,
		},
		Rest: RestConfig{
			RESTPort: DefaultRESTPort,
			RESTHost: DefaultRESTHost,
		},
		Plugin: PluginConfig{
			Wallet: WalletConfig{
				WalletDir:      "",
				WalletRESTPort: DefaultWalletRESTPort,
				WalletRESTHost: DefaultRESTHost,
			},
			Log: LogRestConfig{
				LogRESTPort: DefaultLogRESTPort,
				LogRESTHost: DefaultRESTHost,
			},
			MongoDB: MongoDBConfig{
				URL: "",
			},
		},
		P2P: P2PConfig{
			P2PPort:     DefaultP2PPort,
			P2PServAddr: "192.168.1.1",
			PeerList:    []string{},
			P2PAuthRequried: DefaultP2PAuthRequried,
			P2PAuthKeyList: []string{},
			MaxPeer: DefaultMaxPeer,
		},
		Delegate: DelegateConfig{
			Account:   "",
			Solo:      false,
			Signature: Signature{},
		},
	}

	var err error
	Genesis.GenesisTime, err = timeFromRFC3339(DefaultGenesisTime)
	if err != nil {
		fmt.Printf("Genesis time parse error: %v", err)
		os.Exit(1)
	}
	Genesis.GenesisKey, err = common.HexToBytes(DefaultGenesisKey)
	if err != nil {
		fmt.Printf("Genesis key parse error: %v", err)
		os.Exit(1)
	}
	data, _ := bpl.Marshal(Genesis)
	ChainID = common.DoubleSha256(data)
}

func GetChainID() []byte {
	return ChainID[:]
}

func loadConfigFile(fn string) error {
	f, err := os.Open(fn)
	if err != nil {
		return err
	}
	defer f.Close()

	err = toml.NewDecoder(bufio.NewReader(f)).Decode(&BtoConfig)
	if _, ok := err.(*toml.LineError); ok {
		err = errors.New(fn + ", " + err.Error())
	}
	return err
}

func LoadGenesisFile(fn string) error {
	f, err := os.Open(fn)
	if err != nil {
		return err
	}
	defer f.Close()

	type genesisStruct struct {
		GenesisTime string
		GenesisKey  string
	}
	gs := genesisStruct{}
	err = toml.NewDecoder(bufio.NewReader(f)).Decode(&gs)
	if _, ok := err.(*toml.LineError); ok {
		err = errors.New(fn + ", " + err.Error())
	}
	if err != nil {
		return fmt.Errorf("Genesis file error: %v", err)
	}

	Genesis.GenesisTime, err = timeFromRFC3339(gs.GenesisTime)
	if err != nil {
		return fmt.Errorf("Genesis time parse error: %v", err)
	}
	Genesis.GenesisKey, err = common.HexToBytes(gs.GenesisKey)
	if err != nil {
		return fmt.Errorf("Genesis key parse error: %v", err)
	}

	data, _ := bpl.Marshal(Genesis)
	ChainID = common.DoubleSha256(data)

	return nil
}

func SetGenesisConfig(config *GenesisConfig) {
	Genesis = *config
	data, _ := bpl.Marshal(Genesis)
	ChainID = common.DoubleSha256(data)
}

func timeFromRFC3339(ts string) (uint64, error) {
	if !strings.HasSuffix(ts, "Z") {
		ts += "Z"
	}
	gt, e := time.Parse(time.RFC3339, ts)
	if e != nil {
		return 0, e
	}

	return uint64(gt.Unix()), nil
}

func FileExist(fn string) bool {
	if _, err := os.Stat(fn); os.IsNotExist(err) {
		return false
	}
	return true
}

// LoadConfig is to load config file
func LoadConfig(ctx *cli.Context) error {

	if ctx.GlobalIsSet(cmd.ConfigFileFlag.Name) {
		configFn := ctx.GlobalString(cmd.ConfigFileFlag.Name)
		if err := loadConfigFile(configFn); err != nil {
			return err
		}
	} else {
		configFn := DefaultConfigToml
		if FileExist(configFn) {
			if err := loadConfigFile(configFn); err != nil {
				return err
			}
		}
	}

	// Node
	if ctx.GlobalIsSet(cmd.DataDirFlag.Name) {
		BtoConfig.Node.DataDir = ctx.GlobalString(cmd.DataDirFlag.Name)
	}

	// Rest
	if ctx.GlobalIsSet(cmd.RESTPortFlag.Name) {
		BtoConfig.Rest.RESTPort = ctx.GlobalInt(cmd.RESTPortFlag.Name)
	}
	if _, err := PortValidate(BtoConfig.Rest.RESTPort); err != nil {
		return err
	}

	if ctx.GlobalIsSet(cmd.RESTServerAddrFlag.Name) {
		BtoConfig.Rest.RESTHost = ctx.GlobalString(cmd.RESTServerAddrFlag.Name)
	}
	if _, err := IPValidate(BtoConfig.Rest.RESTHost); err != nil {
		return err
	}

	// P2P
	if ctx.GlobalIsSet(cmd.P2PPortFlag.Name) {
		BtoConfig.P2P.P2PPort = ctx.GlobalInt(cmd.P2PPortFlag.Name)
	}
	if _, err := PortValidate(BtoConfig.P2P.P2PPort); err != nil {
		return err
	}

	if ctx.GlobalIsSet(cmd.P2PServerAddrFlag.Name) {
		BtoConfig.P2P.P2PServAddr = ctx.GlobalString(cmd.P2PServerAddrFlag.Name)
	}

	if ctx.GlobalIsSet(cmd.PeerListFlag.Name) {
		raw := ctx.GlobalString(cmd.PeerListFlag.Name)
		peerList, err := parsePeerListCLI(raw)
		if err != nil {
			return fmt.Errorf("parse peerlist error")
		}
		BtoConfig.P2P.PeerList = make([]string, len(peerList))
		copy(BtoConfig.P2P.PeerList, peerList)
	}

	// Delegate
	if ctx.GlobalIsSet(cmd.DelegateFlag.Name) {
		d := ctx.GlobalString(cmd.DelegateFlag.Name)
		if 0 != strings.Compare(d, "bottos") {
			/*non genesis node, need check username's validation*/
			re := regexp.MustCompile(common.ACCOUNT_NAME_REGEXP)
			if !(re.MatchString(d) && len(d) >= 10) {
				fmt.Println("\nError. Invalid user name.")
				fmt.Println("The correct username should be: \na. Has non-numberic at first character.\nb. Account name length should be bigger than(or equal to) 10.\nc. Other than '.' and '_', any special words cannot be included in your new account name.\nd. Any uppercase characters are not allowed to be present in the account name.")

				return errors.New("Invalid user name format.")
			}
		}
		BtoConfig.Delegate.Account = d
	}

	if ctx.GlobalIsSet(cmd.DelegateSignkeyFlag.Name) {
		raw := ctx.GlobalString(cmd.DelegateSignkeyFlag.Name)
		err := parseKeyPairCLI(raw)
		if err != nil {
			return err
		}
	}

	//Wallet
	if ctx.GlobalIsSet(cmd.WalletRESTPortFlag.Name) {
		BtoConfig.Plugin.Wallet.WalletRESTPort = ctx.GlobalInt(cmd.WalletRESTPortFlag.Name)
	}
	if _, err := PortValidate(BtoConfig.Plugin.Wallet.WalletRESTPort); err != nil {
		return err
	}

	if ctx.GlobalIsSet(cmd.WalletRESTServerAddrFlag.Name) {
		BtoConfig.Plugin.Wallet.WalletRESTHost = ctx.GlobalString(cmd.WalletRESTServerAddrFlag.Name)
	}
	if _, err := IPValidate(BtoConfig.Plugin.Wallet.WalletRESTHost); err != nil {
		return err
	}

	// MongoDB
	if ctx.GlobalIsSet(cmd.MongoDBFlag.Name) {
		BtoConfig.Plugin.MongoDB.URL = ctx.GlobalString(cmd.MongoDBFlag.Name)
	}
	if _, err := MongoURLValidate(BtoConfig.Plugin.MongoDB.URL); err != nil {
		return err
	}

	// Log Config
	if ctx.GlobalIsSet(cmd.LogMinLevelFlag.Name) {
		value := ctx.GlobalString(cmd.LogMinLevelFlag.Name)
		if CheckLogCfgItemValue("minlevel", value) {
			SetLogCfgItemValue("minlevel", value)
		}
	}
	if ctx.GlobalIsSet(cmd.LogMaxLevelFlag.Name) {
		value := ctx.GlobalString(cmd.LogMaxLevelFlag.Name)
		if CheckLogCfgItemValue("maxlevel", value) {
			SetLogCfgItemValue("maxlevel", value)
		}
	}
	if ctx.GlobalIsSet(cmd.LogLevelsFlag.Name) {
		value := ctx.GlobalString(cmd.LogLevelsFlag.Name)
		if CheckLogCfgItemValue("levels", value) {
			SetLogCfgItemValue("levels", value)
		}
	}
	if ctx.GlobalIsSet(cmd.LogMaxrollsFlag.Name) {
		value := ctx.GlobalString(cmd.LogMaxrollsFlag.Name)
		if CheckLogCfgItemValue("maxrolls", value) {
			SetLogCfgItemValue("maxrolls", value)
		}
	}

	return nil
}

func GetDelegateSignKey(pubkey string) ([]byte, error) {
	if pubkey == BtoConfig.Delegate.Signature.PublicKey {
		return common.HexStringToBytes(BtoConfig.Delegate.Signature.PrivateKey), nil
	}

	return nil, fmt.Errorf("Not Found")
}

func parsePeerListCLI(raw string) ([]string, error) {
	var peerList []string
	val := strings.Replace(raw, " ", "", -1)
	peerList = strings.Split(val, ",")
	// check peers
	return peerList, nil
}

func parseKeyPairCLI(raw string) error {
	if strings.HasPrefix(raw, "key:") {
		val := raw[len("key:"):]
		val = strings.Replace(val, " ", "", -1)
		keys := strings.Split(val, ",")
		if len(keys) < 2 {
			return fmt.Errorf("parse delegate signature key error")
		}
		BtoConfig.Delegate.Signature.Type = "key"
		BtoConfig.Delegate.Signature.PublicKey = keys[0]
		BtoConfig.Delegate.Signature.PrivateKey = keys[1]
	} else if strings.HasPrefix(raw, "wallet:") {
		val := raw[len("wallet:"):]
		if len(val) == 0 {
			return fmt.Errorf("parse delegate wallet url error")
		}
		BtoConfig.Delegate.Signature.Type = "wallet"
		BtoConfig.Delegate.Signature.URL = val
	}

	return nil
}

// InitLogConfig initialize log config
func InitLogConfig(ctx *cli.Context) error {
	
	logFileName := filepath.Join(BtoConfig.Node.DataDir, "/log/bottos.log")
	logxml, err := CreateLogXml(logFileName)
	if err != nil {
		return fmt.Errorf("Create logger config error: %v", err)
	}
	defer log.Flush()
	logger, err := log.LoggerFromConfigAsBytes(logxml)
	if err != nil {
		return fmt.Errorf("Init logger error: %v", err)
	}
	
	log.ReplaceLogger(logger)
	
	/*logFileName = filepath.Join(BtoConfig.Node.DataDir, "/log/corefile.log")
	logxml, err = CreateCoreLogXml(logFileName)
	if err != nil {
		return fmt.Errorf("Create core logger config error: %v", err)
	}
	logger, err = log.LoggerFromConfigAsBytes(logxml)
	if err != nil {
		return fmt.Errorf("Init core logger error: %v", err)
	}
	defer logger.Flush()
	
	common.CoreLogger = logger
	*/
	
	return nil
}

func loadConfigJson(fn string) ([]byte, error) {
	file, e := ioutil.ReadFile(fn)
	if e != nil {
		return nil, e
	}

	// Remove the UTF-8 Byte Order Mark
	file = bytes.TrimPrefix(file, []byte("\xef\xbb\xbf"))
	return file, nil
}
